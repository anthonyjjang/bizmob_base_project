# bizMOB4Vue-SI ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜ˆì œ ê°€ì´ë“œ

ì‹¤ì œ ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ì— ë”°ë¥¸ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì˜ˆì œì™€ êµ¬í˜„ ë°©ë²•ì„ ì œì‹œí•©ë‹ˆë‹¤.

## ğŸ“‹ ëª©ì°¨

- [ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”êµ¬ì‚¬í•­ ë¶„ë¥˜](#-ì»¤ìŠ¤í„°ë§ˆì´ì§•-ìš”êµ¬ì‚¬í•­-ë¶„ë¥˜)
- [UI/UX ì»¤ìŠ¤í„°ë§ˆì´ì§•](#-uiux-ì»¤ìŠ¤í„°ë§ˆì´ì§•)
- [ê¸°ëŠ¥ í™•ì¥ ì˜ˆì œ](#-ê¸°ëŠ¥-í™•ì¥-ì˜ˆì œ)
- [API í†µí•© ì»¤ìŠ¤í„°ë§ˆì´ì§•](#-api-í†µí•©-ì»¤ìŠ¤í„°ë§ˆì´ì§•)
- [ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì»¤ìŠ¤í„°ë§ˆì´ì§•](#-ë¹„ì¦ˆë‹ˆìŠ¤-ë¡œì§-ì»¤ìŠ¤í„°ë§ˆì´ì§•)
- [ì„±ëŠ¥ ìµœì í™” ì‚¬ë¡€](#-ì„±ëŠ¥-ìµœì í™”-ì‚¬ë¡€)
- [ë³´ì•ˆ ê°•í™” ì‚¬ë¡€](#-ë³´ì•ˆ-ê°•í™”-ì‚¬ë¡€)
- [ë‹¤êµ­ì–´ ì§€ì› í™•ì¥](#-ë‹¤êµ­ì–´-ì§€ì›-í™•ì¥)

## ğŸ¯ ì»¤ìŠ¤í„°ë§ˆì´ì§• ìš”êµ¬ì‚¬í•­ ë¶„ë¥˜

### Level 1: ê¸°ë³¸ ì»¤ìŠ¤í„°ë§ˆì´ì§• (1-2ì¼)
- ë¸Œëœë”© ìƒ‰ìƒ ë³€ê²½
- ë¡œê³  ë° ì´ë¯¸ì§€ êµì²´
- ê¸°ë³¸ í…ìŠ¤íŠ¸ ìˆ˜ì •
- ê°„ë‹¨í•œ ë ˆì´ì•„ì›ƒ ì¡°ì •

### Level 2: ì¤‘ê¸‰ ì»¤ìŠ¤í„°ë§ˆì´ì§• (3-5ì¼)
- ìƒˆë¡œìš´ í˜ì´ì§€ ì¶”ê°€
- ê¸°ì¡´ í¼ í•„ë“œ ìˆ˜ì •/ì¶”ê°€
- ì»¤ìŠ¤í…€ ì»´í¬ë„ŒíŠ¸ ê°œë°œ
- ì›Œí¬í”Œë¡œìš° ë³€ê²½

### Level 3: ê³ ê¸‰ ì»¤ìŠ¤í„°ë§ˆì´ì§• (1-2ì£¼)
- ë³µí•© ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„
- ì™¸ë¶€ API í†µí•©
- ì‹¤ì‹œê°„ ê¸°ëŠ¥ ì¶”ê°€
- ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬

### Level 4: í”Œë«í¼ í™•ì¥ (2-4ì£¼)
- ìƒˆë¡œìš´ ëª¨ë“ˆ ê°œë°œ
- í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ êµ¬í˜„
- ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ í†µí•©
- ê³ ê¸‰ ë¶„ì„ ë° ë¦¬í¬íŒ…

## ğŸ¨ UI/UX ì»¤ìŠ¤í„°ë§ˆì´ì§•

### 1. ë¸Œëœë“œ í…Œë§ˆ ì»¤ìŠ¤í„°ë§ˆì´ì§•

#### ìš”êµ¬ì‚¬í•­
> **íšŒì‚¬ ë¸Œëœë“œ ìƒ‰ìƒì„ ì ìš©í•˜ê³ , ë¡œê³ ë¥¼ êµì²´í•˜ì—¬ ìì‚¬ ì•±ìœ¼ë¡œ ë¸Œëœë”©**

#### êµ¬í˜„ ë°©ë²•

```scss
// src/assets/css/custom-theme.scss
:root {
  // ê¸°ì¡´ bizMOB ì»¬ëŸ¬ë¥¼ íšŒì‚¬ ë¸Œëœë“œ ì»¬ëŸ¬ë¡œ ë³€ê²½
  --ion-color-primary: #e74c3c;        // íšŒì‚¬ Red
  --ion-color-primary-rgb: 231,76,60;
  --ion-color-primary-contrast: #ffffff;
  --ion-color-primary-shade: #c0392b;
  --ion-color-primary-tint: #ea6153;
  
  // ì„¸ì»¨ë”ë¦¬ ì»¬ëŸ¬
  --ion-color-secondary: #f39c12;      // íšŒì‚¬ Orange
  --ion-color-secondary-rgb: 243,156,18;
  --ion-color-secondary-shade: #d68910;
  --ion-color-secondary-tint: #f5ab35;
  
  // ë¸Œëœë“œ ì „ìš© ì»¬ëŸ¬
  --brand-gradient: linear-gradient(135deg, 
    var(--ion-color-primary) 0%, 
    var(--ion-color-secondary) 100%);
}

// ë¸Œëœë“œ ì „ìš© í´ë˜ìŠ¤
.brand-header {
  background: var(--brand-gradient);
  color: white;
  
  .brand-logo {
    width: 120px;
    height: 40px;
    background: url('../images/brand/company-logo.svg') no-repeat center;
    background-size: contain;
  }
}

.brand-button {
  background: var(--brand-gradient);
  border: none;
  border-radius: 25px;
  
  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
  }
}
```

```vue
<!-- src/components/BrandHeader.vue -->
<template>
  <ion-header class="brand-header">
    <ion-toolbar>
      <div class="brand-logo" slot="start"></div>
      <ion-title>{{ companyName }}</ion-title>
      <ion-buttons slot="end">
        <ion-button @click="openProfile">
          <ion-icon :icon="person"></ion-icon>
        </ion-button>
      </ion-buttons>
    </ion-toolbar>
  </ion-header>
</template>

<script setup lang="ts">
import { person } from 'ionicons/icons';

interface Props {
  companyName?: string;
}

const props = withDefaults(defineProps<Props>(), {
  companyName: 'ìš°ë¦¬ íšŒì‚¬'
});
</script>
```

### 2. ë‹¤í¬ëª¨ë“œ í† ê¸€ êµ¬í˜„

#### ìš”êµ¬ì‚¬í•­
> **ì‚¬ìš©ìê°€ ë¼ì´íŠ¸/ë‹¤í¬ ëª¨ë“œë¥¼ ì „í™˜í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ ì¶”ê°€**

#### êµ¬í˜„ ë°©ë²•

```typescript
// src/composables/useTheme.ts
import { ref, watch } from 'vue';
import { StoreService } from '@/shared';

export function useTheme() {
  const appStore = new StoreService('app');
  const isDarkMode = ref(false);
  
  // ì´ˆê¸° í…Œë§ˆ ë¡œë“œ
  const initTheme = () => {
    const savedTheme = appStore.getters('theme') || 'light';
    isDarkMode.value = savedTheme === 'dark';
    applyTheme(savedTheme);
  };
  
  // í…Œë§ˆ ì ìš©
  const applyTheme = (theme: 'light' | 'dark') => {
    document.documentElement.setAttribute('data-theme', theme);
    document.body.classList.toggle('dark-theme', theme === 'dark');
    
    // Ionic ë‹¤í¬ëª¨ë“œ ì ìš©
    document.body.classList.toggle('ion-palette-dark', theme === 'dark');
  };
  
  // í…Œë§ˆ í† ê¸€
  const toggleTheme = () => {
    const newTheme = isDarkMode.value ? 'light' : 'dark';
    isDarkMode.value = !isDarkMode.value;
    
    appStore.dispatch('setTheme', newTheme);
    applyTheme(newTheme);
  };
  
  // ì‹œìŠ¤í…œ í…Œë§ˆ ê°ì§€
  const detectSystemTheme = () => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    return mediaQuery.matches ? 'dark' : 'light';
  };
  
  return {
    isDarkMode,
    initTheme,
    toggleTheme,
    detectSystemTheme
  };
}
```

```scss
// src/assets/css/dark-theme.scss
[data-theme="dark"] {
  --ion-background-color: #0d1117;
  --ion-text-color: #c9d1d9;
  --ion-color-step-50: #161b22;
  --ion-color-step-100: #21262d;
  --ion-color-step-150: #30363d;
  --ion-color-step-200: #484f58;
  
  .brand-header {
    background: linear-gradient(135deg, #8b2635 0%, #d68910 100%);
  }
  
  .card {
    background-color: var(--ion-color-step-100);
    border: 1px solid var(--ion-color-step-150);
  }
}
```

### 3. ì»¤ìŠ¤í…€ ìŠ¤í”Œë˜ì‹œ í™”ë©´

#### ìš”êµ¬ì‚¬í•­
> **ì•± ë¡œë”© ì¤‘ íšŒì‚¬ ë¸Œëœë“œë¥¼ í‘œì‹œí•˜ëŠ” ì»¤ìŠ¤í…€ ìŠ¤í”Œë˜ì‹œ í™”ë©´ êµ¬í˜„**

#### êµ¬í˜„ ë°©ë²•

```vue
<!-- src/components/CustomSplash.vue -->
<template>
  <div class="splash-container" :class="{ 'fade-out': shouldFadeOut }">
    <div class="splash-content">
      <div class="brand-animation">
        <img src="/images/brand/logo-large.svg" alt="íšŒì‚¬ ë¡œê³ " class="brand-logo-large" />
        <div class="brand-name">{{ companyName }}</div>
        <div class="brand-tagline">{{ tagline }}</div>
      </div>
      
      <div class="loading-indicator">
        <div class="loading-dots">
          <div class="dot"></div>
          <div class="dot"></div>
          <div class="dot"></div>
        </div>
        <div class="loading-text">{{ loadingText }}</div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, nextTick } from 'vue';

interface Props {
  companyName?: string;
  tagline?: string;
  loadingText?: string;
  minDuration?: number;
}

const props = withDefaults(defineProps<Props>(), {
  companyName: 'ìš°ë¦¬ íšŒì‚¬',
  tagline: 'Innovation for Tomorrow',
  loadingText: 'ì•±ì„ ì¤€ë¹„í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
  minDuration: 2000
});

const emit = defineEmits<{
  ready: [];
}>();

const shouldFadeOut = ref(false);

onMounted(async () => {
  // ìµœì†Œ í‘œì‹œ ì‹œê°„ ë³´ì¥
  await new Promise(resolve => setTimeout(resolve, props.minDuration));
  
  shouldFadeOut.value = true;
  
  // í˜ì´ë“œì•„ì›ƒ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì´ë²¤íŠ¸ ë°œìƒ
  setTimeout(() => {
    emit('ready');
  }, 500);
});
</script>

<style scoped lang="scss">
.splash-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: var(--brand-gradient);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease-out;
  
  &.fade-out {
    opacity: 0;
    pointer-events: none;
  }
}

.splash-content {
  text-align: center;
  color: white;
}

.brand-animation {
  animation: slideUpFade 1s ease-out;
  
  .brand-logo-large {
    width: 120px;
    height: 120px;
    margin-bottom: 24px;
    animation: logoGlow 2s ease-in-out infinite alternate;
  }
  
  .brand-name {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 8px;
  }
  
  .brand-tagline {
    font-size: 16px;
    opacity: 0.9;
    margin-bottom: 48px;
  }
}

.loading-indicator {
  .loading-dots {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 16px;
    
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: white;
      animation: dotPulse 1.4s ease-in-out infinite both;
      
      &:nth-child(1) { animation-delay: -0.32s; }
      &:nth-child(2) { animation-delay: -0.16s; }
      &:nth-child(3) { animation-delay: 0s; }
    }
  }
  
  .loading-text {
    font-size: 14px;
    opacity: 0.8;
  }
}

@keyframes slideUpFade {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes logoGlow {
  0% {
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
  }
  100% {
    filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.6));
  }
}

@keyframes dotPulse {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
}
</style>
```

## ğŸš€ ê¸°ëŠ¥ í™•ì¥ ì˜ˆì œ

### 1. ì‹¤ì‹œê°„ ì±„íŒ… ê¸°ëŠ¥ ì¶”ê°€

#### ìš”êµ¬ì‚¬í•­
> **ì‚¬ìš©ì ê°„ ì‹¤ì‹œê°„ ì±„íŒ… ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ì—¬ í˜‘ì—… í™˜ê²½ êµ¬ì¶•**

#### êµ¬í˜„ ë°©ë²•

```typescript
// src/services/ChatService.ts
import { ref, reactive } from 'vue';

interface ChatMessage {
  id: string;
  userId: string;
  userName: string;
  message: string;
  timestamp: Date;
  type: 'text' | 'image' | 'file';
  status: 'sending' | 'sent' | 'failed';
}

interface ChatRoom {
  id: string;
  name: string;
  participants: string[];
  lastMessage: ChatMessage | null;
  unreadCount: number;
}

export class ChatService {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  public messages = ref<ChatMessage[]>([]);
  public rooms = ref<ChatRoom[]>([]);
  public currentRoom = ref<string | null>(null);
  public connectionStatus = ref<'connecting' | 'connected' | 'disconnected'>('disconnected');
  
  // WebSocket ì—°ê²°
  connect(userId: string, token: string) {
    const wsUrl = `${process.env.VUE_APP_WS_URL}/chat?userId=${userId}&token=${token}`;
    
    this.ws = new WebSocket(wsUrl);
    this.connectionStatus.value = 'connecting';
    
    this.ws.onopen = () => {
      this.connectionStatus.value = 'connected';
      this.reconnectAttempts = 0;
      console.log('ì±„íŒ… ì„œë²„ì— ì—°ê²°ë¨');
    };
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleIncomingMessage(data);
    };
    
    this.ws.onclose = () => {
      this.connectionStatus.value = 'disconnected';
      this.attemptReconnect(userId, token);
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket ì—ëŸ¬:', error);
    };
  }
  
  // ë©”ì‹œì§€ ì „ì†¡
  sendMessage(roomId: string, message: string, type: 'text' | 'image' | 'file' = 'text') {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      throw new Error('ì±„íŒ… ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ');
    }
    
    const messageData = {
      type: 'message',
      roomId,
      message,
      messageType: type,
      timestamp: new Date().toISOString()
    };
    
    this.ws.send(JSON.stringify(messageData));
    
    // ë¡œì»¬ì— ì„ì‹œ ë©”ì‹œì§€ ì¶”ê°€ (ë‚™ê´€ì  ì—…ë°ì´íŠ¸)
    this.addLocalMessage({
      id: `temp_${Date.now()}`,
      userId: 'current_user',
      userName: 'ë‚˜',
      message,
      timestamp: new Date(),
      type,
      status: 'sending'
    });
  }
  
  // ë°© ì…ì¥
  joinRoom(roomId: string) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    
    this.currentRoom.value = roomId;
    this.ws.send(JSON.stringify({
      type: 'join_room',
      roomId
    }));
  }
  
  // ë°© ë‚˜ê°€ê¸°
  leaveRoom(roomId: string) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    
    this.ws.send(JSON.stringify({
      type: 'leave_room',
      roomId
    }));
    
    if (this.currentRoom.value === roomId) {
      this.currentRoom.value = null;
    }
  }
  
  private handleIncomingMessage(data: any) {
    switch (data.type) {
      case 'message':
        this.messages.value.push({
          id: data.id,
          userId: data.userId,
          userName: data.userName,
          message: data.message,
          timestamp: new Date(data.timestamp),
          type: data.messageType,
          status: 'sent'
        });
        break;
        
      case 'room_list':
        this.rooms.value = data.rooms;
        break;
        
      case 'user_joined':
        console.log(`${data.userName}ë‹˜ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤.`);
        break;
        
      case 'user_left':
        console.log(`${data.userName}ë‹˜ì´ í‡´ì¥í–ˆìŠµë‹ˆë‹¤.`);
        break;
    }
  }
  
  private addLocalMessage(message: ChatMessage) {
    this.messages.value.push(message);
  }
  
  private attemptReconnect(userId: string, token: string) {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`ì¬ì—°ê²° ì‹œë„ ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
      
      setTimeout(() => {
        this.connect(userId, token);
      }, Math.pow(2, this.reconnectAttempts) * 1000); // ì§€ìˆ˜ ë°±ì˜¤í”„
    }
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}
```

```vue
<!-- src/views/CHAT/CHAT0100.vue -->
<template>
  <ion-page>
    <ion-header>
      <AppHeader title="ì±„íŒ…" :left-buttons="['back']" />
    </ion-header>

    <ion-content>
      <!-- ì—°ê²° ìƒíƒœ í‘œì‹œ -->
      <div v-if="connectionStatus !== 'connected'" class="connection-status">
        <ion-chip :color="connectionStatus === 'connecting' ? 'warning' : 'danger'">
          <ion-icon :icon="connectionStatus === 'connecting' ? time : alertCircle"></ion-icon>
          <ion-label>
            {{ connectionStatus === 'connecting' ? 'ì—°ê²° ì¤‘...' : 'ì—°ê²° ëŠì–´ì§' }}
          </ion-label>
        </ion-chip>
      </div>

      <!-- ì±„íŒ… ë°© ëª©ë¡ -->
      <ion-list v-if="!currentRoom">
        <ion-item
          v-for="room in rooms"
          :key="room.id"
          button
          @click="joinChatRoom(room.id)"
        >
          <ion-avatar slot="start">
            <div class="room-avatar">{{ room.name[0] }}</div>
          </ion-avatar>
          
          <ion-label>
            <h2>{{ room.name }}</h2>
            <p v-if="room.lastMessage">
              {{ room.lastMessage.message }}
            </p>
          </ion-label>
          
          <div slot="end" class="room-meta">
            <ion-badge
              v-if="room.unreadCount > 0"
              color="primary"
              class="unread-badge"
            >
              {{ room.unreadCount }}
            </ion-badge>
            <p class="last-message-time">
              {{ formatTime(room.lastMessage?.timestamp) }}
            </p>
          </div>
        </ion-item>
      </ion-list>

      <!-- ì±„íŒ… ë©”ì‹œì§€ -->
      <div v-else class="chat-messages" ref="messagesContainer">
        <div
          v-for="message in messages"
          :key="message.id"
          class="message-item"
          :class="{
            'message-mine': message.userId === currentUserId,
            'message-other': message.userId !== currentUserId
          }"
        >
          <div class="message-bubble">
            <div class="message-content">
              {{ message.message }}
            </div>
            <div class="message-meta">
              <span class="message-time">
                {{ formatTime(message.timestamp) }}
              </span>
              <ion-icon
                v-if="message.userId === currentUserId"
                :icon="getStatusIcon(message.status)"
                :color="getStatusColor(message.status)"
                class="message-status"
              ></ion-icon>
            </div>
          </div>
        </div>
      </div>
    </ion-content>

    <!-- ë©”ì‹œì§€ ì…ë ¥ -->
    <ion-footer v-if="currentRoom">
      <ion-toolbar>
        <div class="message-input-container">
          <ion-textarea
            v-model="newMessage"
            placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
            :rows="1"
            :auto-grow="true"
            @keydown.enter.prevent="sendMessage"
            class="message-input"
          ></ion-textarea>
          
          <ion-button
            fill="clear"
            @click="sendMessage"
            :disabled="!newMessage.trim() || connectionStatus !== 'connected'"
          >
            <ion-icon :icon="send"></ion-icon>
          </ion-button>
        </div>
      </ion-toolbar>
    </ion-footer>
  </ion-page>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed, nextTick } from 'vue';
import { ChatService } from '@/services/ChatService';
import { send, time, alertCircle, checkmark, checkmarkDone } from 'ionicons/icons';

const chatService = new ChatService();
const newMessage = ref('');
const messagesContainer = ref<HTMLElement>();
const currentUserId = 'current_user'; // ì‹¤ì œ ì‚¬ìš©ì IDë¡œ êµì²´

// Reactive data from service
const { messages, rooms, currentRoom, connectionStatus } = chatService;

const joinChatRoom = (roomId: string) => {
  chatService.joinRoom(roomId);
  scrollToBottom();
};

const sendMessage = async () => {
  if (!newMessage.value.trim() || !currentRoom.value) return;
  
  try {
    await chatService.sendMessage(currentRoom.value, newMessage.value);
    newMessage.value = '';
    scrollToBottom();
  } catch (error) {
    console.error('ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨:', error);
  }
};

const scrollToBottom = async () => {
  await nextTick();
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
  }
};

const formatTime = (timestamp: Date | undefined) => {
  if (!timestamp) return '';
  return new Intl.DateTimeFormat('ko-KR', {
    hour: '2-digit',
    minute: '2-digit'
  }).format(timestamp);
};

const getStatusIcon = (status: string) => {
  switch (status) {
    case 'sending': return time;
    case 'sent': return checkmark;
    case 'failed': return alertCircle;
    default: return checkmark;
  }
};

const getStatusColor = (status: string) => {
  switch (status) {
    case 'sending': return 'medium';
    case 'sent': return 'success';
    case 'failed': return 'danger';
    default: return 'medium';
  }
};

onMounted(() => {
  // ì‚¬ìš©ì í† í°ìœ¼ë¡œ ì±„íŒ… ì„œë²„ ì—°ê²°
  const userToken = 'user_jwt_token'; // ì‹¤ì œ í† í°ìœ¼ë¡œ êµì²´
  chatService.connect(currentUserId, userToken);
});

onUnmounted(() => {
  chatService.disconnect();
});
</script>

<style scoped lang="scss">
.connection-status {
  padding: 8px 16px;
  background: rgba(255, 193, 7, 0.1);
  text-align: center;
}

.chat-messages {
  padding: 16px;
  min-height: 100%;
  
  .message-item {
    margin-bottom: 16px;
    
    &.message-mine {
      display: flex;
      justify-content: flex-end;
      
      .message-bubble {
        background: var(--ion-color-primary);
        color: white;
        border-radius: 18px 18px 4px 18px;
      }
    }
    
    &.message-other {
      display: flex;
      justify-content: flex-start;
      
      .message-bubble {
        background: var(--ion-color-light);
        color: var(--ion-color-dark);
        border-radius: 18px 18px 18px 4px;
      }
    }
  }
  
  .message-bubble {
    max-width: 70%;
    padding: 12px 16px;
    
    .message-content {
      margin-bottom: 4px;
      line-height: 1.4;
    }
    
    .message-meta {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      font-size: 12px;
      opacity: 0.7;
      
      .message-time {
        margin-right: 4px;
      }
      
      .message-status {
        font-size: 14px;
      }
    }
  }
}

.message-input-container {
  display: flex;
  align-items: end;
  padding: 8px;
  
  .message-input {
    flex: 1;
    margin-right: 8px;
  }
}

.room-meta {
  text-align: right;
  
  .unread-badge {
    margin-bottom: 4px;
  }
  
  .last-message-time {
    font-size: 12px;
    color: var(--ion-color-medium);
  }
}

.room-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--ion-color-primary);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}
</style>
```

### 2. ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì§€ì›

#### ìš”êµ¬ì‚¬í•­
> **ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ì—†ì–´ë„ ê¸°ë³¸ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì˜¤í”„ë¼ì¸ ëª¨ë“œ êµ¬í˜„**

#### êµ¬í˜„ ë°©ë²•

```typescript
// src/services/OfflineService.ts
import { ref } from 'vue';

interface OfflineAction {
  id: string;
  type: 'CREATE' | 'UPDATE' | 'DELETE';
  endpoint: string;
  data: any;
  timestamp: Date;
  retryCount: number;
}

export class OfflineService {
  private syncQueue: OfflineAction[] = [];
  private isOnline = ref(navigator.onLine);
  private syncInProgress = ref(false);
  
  constructor() {
    // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
    
    // ì €ì¥ëœ í ë³µì›
    this.restoreQueue();
  }
  
  // ì˜¤í”„ë¼ì¸ ì•¡ì…˜ íì— ì¶”ê°€
  queueAction(action: Omit<OfflineAction, 'id' | 'timestamp' | 'retryCount'>) {
    const queueItem: OfflineAction = {
      ...action,
      id: `offline_${Date.now()}_${Math.random()}`,
      timestamp: new Date(),
      retryCount: 0
    };
    
    this.syncQueue.push(queueItem);
    this.saveQueue();
    
    // ì˜¨ë¼ì¸ ìƒíƒœë©´ ì¦‰ì‹œ ë™ê¸°í™” ì‹œë„
    if (this.isOnline.value) {
      this.syncPendingActions();
    }
  }
  
  // íœë”© ì•¡ì…˜ ë™ê¸°í™”
  async syncPendingActions() {
    if (!this.isOnline.value || this.syncInProgress.value || this.syncQueue.length === 0) {
      return;
    }
    
    this.syncInProgress.value = true;
    
    const actionsToSync = [...this.syncQueue];
    const failedActions: OfflineAction[] = [];
    
    for (const action of actionsToSync) {
      try {
        await this.executeAction(action);
        console.log(`ì˜¤í”„ë¼ì¸ ì•¡ì…˜ ë™ê¸°í™” ì™„ë£Œ: ${action.type} ${action.endpoint}`);
      } catch (error) {
        console.error(`ì˜¤í”„ë¼ì¸ ì•¡ì…˜ ë™ê¸°í™” ì‹¤íŒ¨: ${action.id}`, error);
        
        action.retryCount++;
        if (action.retryCount < 3) {
          failedActions.push(action);
        } else {
          console.warn(`ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼, ì•¡ì…˜ ì œê±°: ${action.id}`);
        }
      }
    }
    
    this.syncQueue = failedActions;
    this.saveQueue();
    this.syncInProgress.value = false;
  }
  
  private async executeAction(action: OfflineAction): Promise<void> {
    const { type, endpoint, data } = action;
    
    let method: string;
    switch (type) {
      case 'CREATE': method = 'POST'; break;
      case 'UPDATE': method = 'PUT'; break;
      case 'DELETE': method = 'DELETE'; break;
      default: throw new Error(`Unknown action type: ${type}`);
    }
    
    const response = await fetch(endpoint, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getAuthToken()}`
      },
      body: type !== 'DELETE' ? JSON.stringify(data) : undefined
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
  }
  
  private handleOnline() {
    console.log('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ë¨');
    this.isOnline.value = true;
    
    // ì˜¨ë¼ì¸ ìƒíƒœê°€ ë˜ë©´ íœë”© ì•¡ì…˜ ë™ê¸°í™”
    setTimeout(() => {
      this.syncPendingActions();
    }, 1000);
  }
  
  private handleOffline() {
    console.log('ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠì–´ì§');
    this.isOnline.value = false;
  }
  
  private saveQueue() {
    localStorage.setItem('offline_sync_queue', JSON.stringify(this.syncQueue));
  }
  
  private restoreQueue() {
    try {
      const saved = localStorage.getItem('offline_sync_queue');
      if (saved) {
        this.syncQueue = JSON.parse(saved).map((item: any) => ({
          ...item,
          timestamp: new Date(item.timestamp)
        }));
      }
    } catch (error) {
      console.error('ì˜¤í”„ë¼ì¸ í ë³µì› ì‹¤íŒ¨:', error);
      this.syncQueue = [];
    }
  }
  
  private getAuthToken(): string {
    // ì¸ì¦ í† í° ë°˜í™˜ ë¡œì§
    return localStorage.getItem('auth_token') || '';
  }
  
  // Public getters
  get isOnlineStatus() {
    return this.isOnline;
  }
  
  get pendingActionsCount() {
    return this.syncQueue.length;
  }
  
  get isSyncing() {
    return this.syncInProgress;
  }
}

// ì „ì—­ ì˜¤í”„ë¼ì¸ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
export const offlineService = new OfflineService();
```

```typescript
// src/composables/useOfflineData.ts
import { ref, computed } from 'vue';

interface CacheItem<T> {
  data: T;
  timestamp: Date;
  ttl: number; // Time to live in milliseconds
}

export function useOfflineData<T>(key: string, ttl: number = 5 * 60 * 1000) {
  const cacheKey = `offline_cache_${key}`;
  
  // ë¡œì»¬ ìºì‹œì—ì„œ ë°ì´í„° ë¡œë“œ
  const loadFromCache = (): T | null => {
    try {
      const cached = localStorage.getItem(cacheKey);
      if (!cached) return null;
      
      const cacheItem: CacheItem<T> = JSON.parse(cached);
      const now = new Date().getTime();
      const cacheTime = new Date(cacheItem.timestamp).getTime();
      
      // TTL ì²´í¬
      if (now - cacheTime > cacheItem.ttl) {
        localStorage.removeItem(cacheKey);
        return null;
      }
      
      return cacheItem.data;
    } catch (error) {
      console.error('ìºì‹œ ë¡œë“œ ì‹¤íŒ¨:', error);
      return null;
    }
  };
  
  // ë¡œì»¬ ìºì‹œì— ë°ì´í„° ì €ì¥
  const saveToCache = (data: T) => {
    try {
      const cacheItem: CacheItem<T> = {
        data,
        timestamp: new Date(),
        ttl
      };
      localStorage.setItem(cacheKey, JSON.stringify(cacheItem));
    } catch (error) {
      console.error('ìºì‹œ ì €ì¥ ì‹¤íŒ¨:', error);
    }
  };
  
  // ìºì‹œ ì‚­ì œ
  const clearCache = () => {
    localStorage.removeItem(cacheKey);
  };
  
  // ìºì‹œëœ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€
  const hasCachedData = computed(() => {
    return loadFromCache() !== null;
  });
  
  return {
    loadFromCache,
    saveToCache,
    clearCache,
    hasCachedData
  };
}
```

```vue
<!-- src/components/NetworkStatus.vue -->
<template>
  <ion-toast
    :is-open="showOfflineToast"
    message="ì˜¤í”„ë¼ì¸ ëª¨ë“œì…ë‹ˆë‹¤. ì¼ë¶€ ê¸°ëŠ¥ì´ ì œí•œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    :duration="0"
    position="top"
    color="warning"
    :buttons="[
      {
        text: 'í™•ì¸',
        role: 'cancel'
      }
    ]"
    @didDismiss="showOfflineToast = false"
  ></ion-toast>
  
  <ion-toast
    :is-open="showSyncToast"
    :message="syncMessage"
    :duration="3000"
    position="bottom"
    color="success"
  ></ion-toast>
  
  <!-- ë™ê¸°í™” ìƒíƒœ í‘œì‹œ -->
  <ion-chip
    v-if="pendingCount > 0"
    color="warning"
    class="sync-status-chip"
    @click="forcSync"
  >
    <ion-icon :icon="isSyncing ? hourglass : cloud" class="sync-icon"></ion-icon>
    <ion-label>
      {{ isSyncing ? 'ë™ê¸°í™” ì¤‘...' : `${pendingCount}ê°œ ëŒ€ê¸° ì¤‘` }}
    </ion-label>
  </ion-chip>
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue';
import { offlineService } from '@/services/OfflineService';
import { cloud, hourglass } from 'ionicons/icons';

const showOfflineToast = ref(false);
const showSyncToast = ref(false);
const syncMessage = ref('');

// ì˜¤í”„ë¼ì¸ ì„œë¹„ìŠ¤ ìƒíƒœ
const isOnline = computed(() => offlineService.isOnlineStatus.value);
const pendingCount = computed(() => offlineService.pendingActionsCount);
const isSyncing = computed(() => offlineService.isSyncing.value);

// ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ê°ì§€
watch(isOnline, (online) => {
  if (!online) {
    showOfflineToast.value = true;
  } else {
    showOfflineToast.value = false;
    if (pendingCount.value > 0) {
      syncMessage.value = `${pendingCount.value}ê°œ í•­ëª©ì„ ë™ê¸°í™”í•©ë‹ˆë‹¤.`;
      showSyncToast.value = true;
    }
  }
});

// ë™ê¸°í™” ì™„ë£Œ ê°ì§€
watch([pendingCount, isSyncing], ([newCount, syncing]) => {
  if (!syncing && newCount === 0) {
    syncMessage.value = 'ëª¨ë“  ë°ì´í„°ê°€ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.';
    showSyncToast.value = true;
  }
});

const forcSync = () => {
  if (isOnline.value) {
    offlineService.syncPendingActions();
  }
};
</script>

<style scoped lang="scss">
.sync-status-chip {
  position: fixed;
  top: 60px;
  right: 16px;
  z-index: 1000;
  cursor: pointer;
  
  .sync-icon {
    animation: spin 2s linear infinite;
  }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>
```

## ğŸ”’ ë³´ì•ˆ ê°•í™” ì‚¬ë¡€

### 1. ìƒì²´ ì¸ì¦ í†µí•©

#### ìš”êµ¬ì‚¬í•­
> **ì§€ë¬¸/ì–¼êµ´ ì¸ì‹ì„ í†µí•œ ìƒì²´ ì¸ì¦ ê¸°ëŠ¥ ì¶”ê°€**

#### êµ¬í˜„ ë°©ë²•

```typescript
// src/services/BiometricService.ts
import { Capacitor } from '@capacitor/core';
import { BiometricAuth, BiometryType } from '@aparajita/capacitor-biometric-auth';

export class BiometricService {
  private isAvailable = false;
  private supportedTypes: BiometryType[] = [];
  
  async initialize(): Promise<void> {
    if (!Capacitor.isNativePlatform()) {
      console.log('ìƒì²´ ì¸ì¦ì€ ë„¤ì´í‹°ë¸Œ í”Œë«í¼ì—ì„œë§Œ ì§€ì›ë©ë‹ˆë‹¤.');
      return;
    }
    
    try {
      const result = await BiometricAuth.checkBiometry();
      this.isAvailable = result.isAvailable;
      this.supportedTypes = result.biometryTypes;
      
      console.log('ì§€ì›ë˜ëŠ” ìƒì²´ ì¸ì¦:', this.supportedTypes);
    } catch (error) {
      console.error('ìƒì²´ ì¸ì¦ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
    }
  }
  
  async authenticate(reason: string = 'ì•±ì— ë¡œê·¸ì¸í•˜ê¸° ìœ„í•´ ìƒì²´ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.'): Promise<boolean> {
    if (!this.isAvailable) {
      throw new Error('ìƒì²´ ì¸ì¦ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
    
    try {
      await BiometricAuth.authenticate({
        reason,
        cancelTitle: 'ì·¨ì†Œ',
        allowDeviceCredential: true,
        iosFallbackTitle: 'íŒ¨ìŠ¤ì½”ë“œ ì‚¬ìš©',
        androidTitle: 'ìƒì²´ ì¸ì¦',
        androidSubtitle: 'ë“±ë¡ëœ ìƒì²´ ì •ë³´ë¡œ ì¸ì¦í•˜ì„¸ìš”',
        androidConfirmationRequired: false,
        androidNegativeButtonText: 'ì·¨ì†Œ'
      });
      
      return true;
    } catch (error: any) {
      console.error('ìƒì²´ ì¸ì¦ ì‹¤íŒ¨:', error);
      
      // ì—ëŸ¬ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
      switch (error.code) {
        case 'userCancel':
          throw new Error('ì‚¬ìš©ìê°€ ì¸ì¦ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.');
        case 'biometryNotEnrolled':
          throw new Error('ë“±ë¡ëœ ìƒì²´ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
        case 'biometryNotAvailable':
          throw new Error('ìƒì²´ ì¸ì¦ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        default:
          throw new Error('ìƒì²´ ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    }
  }
  
  get isBiometricAvailable(): boolean {
    return this.isAvailable;
  }
  
  get supportedBiometryTypes(): BiometryType[] {
    return this.supportedTypes;
  }
  
  getBiometryTypeText(type: BiometryType): string {
    switch (type) {
      case BiometryType.fingerprintAuthentication:
        return 'ì§€ë¬¸ ì¸ì‹';
      case BiometryType.faceAuthentication:
        return 'ì–¼êµ´ ì¸ì‹';
      case BiometryType.touchId:
        return 'Touch ID';
      case BiometryType.faceId:
        return 'Face ID';
      default:
        return 'ìƒì²´ ì¸ì¦';
    }
  }
}

export const biometricService = new BiometricService();
```

```vue
<!-- src/components/BiometricLogin.vue -->
<template>
  <div class="biometric-login">
    <div class="biometric-option" v-if="isBiometricAvailable">
      <ion-button
        expand="block"
        fill="outline"
        @click="authenticateWithBiometric"
        :disabled="isAuthenticating"
        class="biometric-button"
      >
        <ion-icon :icon="fingerPrint" slot="start"></ion-icon>
        {{ biometricButtonText }}
      </ion-button>
      
      <ion-loading
        :is-open="isAuthenticating"
        message="ìƒì²´ ì¸ì¦ ì¤‘..."
      ></ion-loading>
    </div>
    
    <div class="biometric-setup" v-else-if="canSetupBiometric">
      <ion-card>
        <ion-card-header>
          <ion-card-title>ìƒì²´ ì¸ì¦ ì„¤ì •</ion-card-title>
        </ion-card-header>
        <ion-card-content>
          <p>ë” ì•ˆì „í•˜ê³  í¸ë¦¬í•œ ë¡œê·¸ì¸ì„ ìœ„í•´ ìƒì²´ ì¸ì¦ì„ ì„¤ì •í•˜ì„¸ìš”.</p>
          <ion-button
            expand="block"
            @click="promptBiometricSetup"
          >
            ìƒì²´ ì¸ì¦ ì„¤ì •í•˜ê¸°
          </ion-button>
        </ion-card-content>
      </ion-card>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { biometricService } from '@/services/BiometricService';
import { useMessage } from '@/shared';
import { fingerPrint } from 'ionicons/icons';

const emit = defineEmits<{
  success: [];
  error: [string];
}>();

const isAuthenticating = ref(false);
const isBiometricAvailable = ref(false);
const supportedTypes = ref<string[]>([]);

const { alert, confirm } = useMessage();

const biometricButtonText = computed(() => {
  if (supportedTypes.value.length === 0) return 'ìƒì²´ ì¸ì¦ìœ¼ë¡œ ë¡œê·¸ì¸';
  
  const typeTexts = supportedTypes.value.map(type => 
    biometricService.getBiometryTypeText(type as any)
  );
  
  return `${typeTexts.join('/')}ë¡œ ë¡œê·¸ì¸`;
});

const canSetupBiometric = computed(() => {
  // ìƒì²´ ì¸ì¦ì€ ì‚¬ìš©í•  ìˆ˜ ì—†ì§€ë§Œ ì„¤ì • ê°€ëŠ¥í•œ ê²½ìš°
  return !isBiometricAvailable.value && supportedTypes.value.length > 0;
});

const authenticateWithBiometric = async () => {
  if (isAuthenticating.value) return;
  
  isAuthenticating.value = true;
  
  try {
    const success = await biometricService.authenticate();
    if (success) {
      emit('success');
    }
  } catch (error: any) {
    console.error('ìƒì²´ ì¸ì¦ ì‹¤íŒ¨:', error);
    emit('error', error.message);
    
    // ì‚¬ìš©ì ì·¨ì†Œê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
    if (!error.message.includes('ì·¨ì†Œ')) {
      await alert(error.message);
    }
  } finally {
    isAuthenticating.value = false;
  }
};

const promptBiometricSetup = async () => {
  const confirmed = await confirm({
    title: 'ìƒì²´ ì¸ì¦ ì„¤ì •',
    text: 'ë””ë°”ì´ìŠ¤ ì„¤ì •ì—ì„œ ìƒì²´ ì¸ì¦ì„ í™œì„±í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
    buttons: [{
      text: 'ì·¨ì†Œ',
      handler: () => false
    }, {
      text: 'ì„¤ì •ìœ¼ë¡œ ì´ë™',
      handler: () => true
    }]
  });
  
  if (confirmed) {
    // ë””ë°”ì´ìŠ¤ ì„¤ì • ì•±ìœ¼ë¡œ ì´ë™í•˜ëŠ” ë¡œì§
    // (ì‹¤ì œ êµ¬í˜„ì€ í”Œë«í¼ë³„ ë„¤ì´í‹°ë¸Œ ì½”ë“œ í•„ìš”)
    await alert('ë””ë°”ì´ìŠ¤ ì„¤ì • > ë³´ì•ˆì—ì„œ ìƒì²´ ì¸ì¦ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
  }
};

onMounted(async () => {
  await biometricService.initialize();
  isBiometricAvailable.value = biometricService.isBiometricAvailable;
  supportedTypes.value = biometricService.supportedBiometryTypes.map(type => 
    biometricService.getBiometryTypeText(type)
  );
});
</script>

<style scoped lang="scss">
.biometric-login {
  margin-top: 24px;
  
  .biometric-button {
    --border-color: var(--ion-color-primary);
    --color: var(--ion-color-primary);
    margin-bottom: 16px;
    
    ion-icon {
      font-size: 20px;
    }
  }
  
  .biometric-setup {
    margin-top: 16px;
    
    ion-card {
      margin: 0;
      
      p {
        margin-bottom: 16px;
        color: var(--ion-color-medium);
      }
    }
  }
}
</style>
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Create initial setup environment configuration guide", "status": "completed", "id": "1"}, {"content": "Create design and style guide for UI components", "status": "completed", "id": "2"}, {"content": "Create publishing guide for HTML/CSS development", "status": "completed", "id": "3"}, {"content": "Define customization example requirements", "status": "completed", "id": "4"}, {"content": "Create live coding task samples", "status": "in_progress", "id": "5"}]